{"meta":{"title":"一个头秃的强化基础班现充的博客","subtitle":"私は、あなたを信じる。","description":"undefined","author":"玖肆veine","url":"kuyon-veine.github.io","root":"/"},"pages":[{"title":"一个头秃的强化基础班的现充的介绍","date":"2020-08-05T10:24:44.000Z","updated":"2020-08-06T06:16:57.442Z","comments":true,"path":"about/index.html","permalink":"kuyon-veine.github.io/about/index.html","excerpt":"","text":"新高一，文化课蒟蒻，NOIp败犬，擅长galgame。 总结：一事无成。 $$"}],"posts":[{"title":"SEG#7分析","slug":"SEG-7分析","date":"2020-08-05T10:24:44.000Z","updated":"2020-08-06T06:22:46.505Z","comments":true,"path":"2020/08/05/SEG-7分析/","link":"","permalink":"kuyon-veine.github.io/2020/08/05/SEG-7分析/","excerpt":"80分。倒一。我 裂 开 了。 %%% TosakaUCW 巨佬，270分orz","text":"80分。倒一。我 裂 开 了。 %%% TosakaUCW 巨佬，270分orz 比赛链接：SEG#7 T1：最美回文第一眼看到题，暴搜，一个一个看过去，顺便记录最大值，初始代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#pragma GCC optimize(\"-O2\")#define ull unsigned long long#define fora(x,a,b) for(int x=a;x&lt;=b;x++)#define forb(x,a,b) for(int x=a;x&gt;=b;x--)#define inf (0x7fffffff)#define abss(x) ((x)&gt;(0)?(x):(-1)*(x))#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))#define sqre(x) ((x)*(x))#define cube(x) ((x)*(x)*(x))#define fastiostream ios::sync_with_stdio(false)using namespace std;int beaudeg[26]=&#123;&#125;;int main()&#123; fora(i,0,25) &#123; scanf(\"%d\",&amp;beaudeg[i]);//读入 &#125; char str[1000001]=&#123;&#125;; scanf(\"%s\",str); int he,ta; int mabedeg=0-inf,bedeg; fora(i,0,strlen(str)-1)//逐位暴力搜索 &#123; bedeg=beaudeg[str[i]-'a'];//向两边搜索 for (he=i+1, ta=i-1;he&lt;=strlen(str)-1&amp;&amp;ta&gt;=0&amp;&amp;str[he]==str[ta];he++, ta--)//遇到不同字符或边界则停止 &#123; bedeg+=(beaudeg[str[he]-'a']&lt;&lt;1);//每轮加上字符值 &#125; mabedeg=maxx(mabedeg, bedeg);//比较，记录 &#125; printf(\"%d\\n\", mabedeg);//输出 return 0;&#125; 提交，30分。 我裂开了。 不是因为TLE，而是因为WA。 我这么严密的程序，怎么可能会WA呢？ 仔细一看数据，不对啊阿sir，我的数据居然比答案小？ 挠了挠头，半小时之后，啊！回文数又不只是cbabc，可能是cbaabc啊！ 我太巨了！ 修改了一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define ull unsigned long long#define fora(x,a,b) for(int x=a;x&lt;=b;x++)#define forb(x,a,b) for(int x=a;x&gt;=b;x--)#define inf (0x7fffffff)#define abss(x) ((x)&gt;(0)?(x):(-1)*(x))#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))#define sqre(x) ((x)*(x))#define cube(x) ((x)*(x)*(x))#define fastiostream ios::sync_with_stdio(false)using namespace std;int beaudeg[26]=&#123;&#125;;int main()&#123; fora(i, 0, 25) &#123; scanf(\"%d\", &amp;beaudeg[i]);//读入 &#125; char str[1000001]=&#123;&#125;; scanf(\"%s\", str); int he, ta; int mabedeg=0-inf, bedeg; fora(i, 0, strlen(str)-1)//逐位暴力搜索 &#123; bedeg=beaudeg[str[i]-'a'];//单字符向两边搜索 for (he=i+1, ta=i-1;he&lt;=strlen(str)-1&amp;&amp;ta&gt;=0&amp;&amp;str[he]==str[ta];he++, ta--)//遇到不同字符或边界则停止 &#123; bedeg+=(beaudeg[str[he]-'a']&lt;&lt;1);//每轮加上字符值 &#125; mabedeg=maxx(mabedeg, bedeg);//比较，记录 if (str[i]==str[i+1])//双字符特判 &#123; bedeg=beaudeg[str[i]-'a']&lt;&lt;1; for (he=i+2, ta=i-1;he&lt;=strlen(str)-1&amp;&amp;ta&gt;=0&amp;&amp;str[he]==str[ta];he++, ta--) &#123; bedeg+=(beaudeg[str[he]-'a']&lt;&lt;1); &#125; mabedeg=maxx(mabedeg, bedeg); &#125; &#125; printf(\"%d\\n\", mabedeg);//输出 return 0;&#125; 漂亮！我不WA了！ 但是，我还是T啊。 继续改进。 经过尝试，开register和吸氧（无论是氧气还是臭氧）都没用。 算法改进。 找到标程，深入学习（经过修改，对程序运行无影响，纯粹自己看着舒服）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))using namespace std;const int N=2000005, M=125;int len, r, p, ans, v[M], f[N], sum[N];char s[N&lt;&lt;1], t[N];int main()&#123; for (int i='a';i&lt;='z';i++) &#123; scanf(\"%d\", &amp;v[i]); &#125; scanf(\"%s\", s+1); len=strlen(s+1); for (int i=1;i&lt;=len;i++) &#123; t[i&lt;&lt;1]=s[i]; t[i&lt;&lt;1|1]='#'; &#125; t[0]='@'; t[1]='#'; t[len=(len+1)&lt;&lt;1]='$'; for (int i=1;i&lt;len;i++) &#123; sum[i]=sum[i-1]+v[t[i]]; &#125; for (int i=1;i&lt;len;i++) &#123; f[i]=r&gt;i?minn(r-i, f[p*2-i]):1; while (t[i-f[i]]==t[i+f[i]]) &#123; f[i]++; &#125; if (i+f[i]&gt;r) r=i+zf[i], p=i; ans=maxx(ans, sum[i+f[i]-1]-sum[i-f[i]]); &#125; printf(\"%d\\n\", ans); return 0;&#125; 标程就是标程，真是难理解。 开始学习（学习之前请一定先对马拉车有一定了解）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))using namespace std;const int N=2000005, M=125;int len, r, p, ans, v[M], f[N], sum[N];char s[N&lt;&lt;1], t[N];int main()&#123; for (int i='a';i&lt;='z';i++) &#123; scanf(\"%d\", &amp;v[i]);//读入 &#125; scanf(\"%s\", s+1); len=strlen(s+1);//保存字符串长度 for (int i=1;i&lt;=len;i++) &#123; t[i&lt;&lt;1]=s[i];//加入间隔\"#\"，将双符回文转化为单符回文 t[i&lt;&lt;1|1]='#'; &#125; t[0]='@';//加入起始符 t[1]='#'; t[len=(len+1)&lt;&lt;1]='$';//加入终止符 for (int i=1;i&lt;len;i++) &#123; sum[i]=sum[i-1]+v[t[i]];//计算字符值总和 &#125; for (int i=1;i&lt;len;i++) &#123; f[i]=r&gt;i?minn(r-i, f[p*2-i]):1;//若i在最右回文范围外，则回文半径取一，暴扫； //若i在最右回文半径内，则取i关于最大回文中心对称点的半径与i到最右回文半径中的最小值以保证当前回文半径内皆为回文 while (t[i-f[i]]==t[i+f[i]])//扩大半径，向两边扫描 &#123; f[i]++; &#125; if (i+f[i]&gt;r) r=i+f[i], p=i;//若当前右回文边界超过先前的最大回文边界，则储存 ans=maxx(ans, sum[i+f[i]-1]-sum[i-f[i]]);//存储答案 &#125; printf(\"%d\\n\", ans);//输出 return 0;&#125; ！！！我惊了！！！ 啊这如此女少的算法！ 马拉车NB！ 最后附上本题自解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#pragma GCC optimize(\"-O3\")#define ull unsigned long long#define fora(x,a,b) for(register int x=a;x&lt;=b;x++)#define forb(x,a,b) for(register int x=a;x&gt;=b;x--)#define inf (0x7fffffff)#define abss(x) ((x)&gt;(0)?(x):(-1)*(x))#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))#define sqre(x) ((x)*(x))#define cube(x) ((x)*(x)*(x))#define fastiostream ios::sync_with_stdio(false)using namespace std;int beaudeg[26]=&#123;&#125;, sum[4000001]=&#123;&#125;, f[4000001]=&#123;&#125;;char s[4000001]=&#123;&#125;;int l, p, r=-1, len, ans;int main()&#123; fora(i, 0, 25) &#123; cin&gt;&gt;beaudeg[i]; &#125; scanf(\"%s\", s); len=strlen(s); s[len&lt;&lt;1]='#'; forb(i, len-1, 0) &#123; s[(i&lt;&lt;1)+1]=s[i]; s[(i&lt;&lt;1)]='#'; &#125; fora(i, 0, (len&lt;&lt;1)-1) &#123; sum[i]=((i!=0)?(sum[i-1]):0)+((s[i]=='#')?0:(beaudeg[s[i]-'a'])); &#125; ans=0; fora(i, 0, (len&lt;&lt;1)-1) &#123; f[i]=(i&lt;r)?(minn(r-i, f[(p&lt;&lt;1)-i])):0; while (i+f[i]&lt;=(len&lt;&lt;1)-1&amp;&amp;i&gt;=f[i]&amp;&amp;s[i+f[i]]==s[i-f[i]]) &#123; f[i]++; &#125; if (i+f[i]&gt;r) &#123; r=i+f[i]; p=i; &#125; ans=maxx(ans, sum[i+f[i]-1]-sum[i-f[i]]); &#125; cout&lt;&lt;ans&lt;&lt;endl; system(\"pause\"); return 0;&#125; （本题结束，完结撒花！） T2:最长公共前缀第一印象：暴搜： 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#include&lt;vector&gt;#include&lt;queue&gt;#pragma GCC optimize(\"-O3\")#define ull unsigned long long#define fora(x,a,b) for(int x=a;x&lt;=b;x++)#define forb(x,a,b) for(int x=a;x&gt;=b;x--)#define inf (0x7fffffff)#define abss(x) ((x)&gt;(0)?(x):(-1)*(x))#define maxx(a,b) ((a)&gt;(b)?(a):(b))#define minn(a,b) ((a)&lt;(b)?(a):(b))#define sqre(x) ((x)*(x))#define cube(x) ((x)*(x)*(x))#define fastiostream ios::sync_with_stdio(false)using namespace std;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); char str[n+1]; memset(str,0,sizeof(str)); scanf(\"%s\",str); int a,b,c,d; int len; fora(i,0,m-1) &#123; scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); for(len=0;len&lt;=minn(b-a-2,d-c-2),str[a+len-1]==str[c+len-1];len++); printf(\"%d\\n\",len); &#125; return 0;&#125; 结果：20分 R，WA，T一起来。 首先检查是否有数组越界，以此判断R。 标程如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;using namespace std;const int N=100010, P=31, D=1000173169;typedef long long ll;int n, m, i, a, b, c, d, pow[N], f[N];char s[N];int hash(int l, int r)&#123; return(ll)(f[r]-(ll)f[l-1]*pow[r-l+1]%D+D)%D;&#125;int ask(int a, int b, int c, int d)&#123; int l=1, r=b-a+1, mid, t=0; if (d-c+1&lt;r) &#123; r=d-c+1; &#125; while (l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(hash(a, a+mid-1)==hash(c, c+mid-1)) &#123; l=(t=mid)+1; &#125; else &#123; r=mid-1; &#125; &#125; return t;&#125;int main()&#123; scanf(\"%d%d%s\", &amp;n, &amp;m, s+1); for (pow[0]=i=1;i&lt;=n;i++) &#123; pow[i]=(ll)pow[i-1]*P%D; &#125; for (i=1;i&lt;=n;i++) &#123; f[i]=(ll)((ll)f[i-1]*P+s[i])%D; &#125; while (m--) &#123; scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;c, &amp;d); printf(\"%d\\n\", ask(a, b, c, d)); &#125; return 0;&#125; T3:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int N=100005;int n, k, ans;struct Trie&#123; int sz, ch[N*10][26], val[N*10]; Trie() &#123; sz=1;memset(ch[0], 0, sizeof(ch[0])); &#125; int idx(char c) &#123; return c-'a'; &#125; void insert(char *s, int v) &#123; int u=0; for (int i=0;i&lt;v;i++) &#123; int c=idx(*(s+i)); if (!ch[u][c]) &#123; memset(ch[sz], 0, sizeof(ch[sz])); val[sz]=0; ch[u][c]=sz++; &#125; u=ch[u][c]; &#125; if (++val[u]&gt;ans) &#123; ans=val[u]; &#125; &#125;&#125;T;char s[N];int main()&#123; scanf(\"%d%d\\n%s\", &amp;n, &amp;k, s); for (int i=0;i&lt;=n-k;i++) &#123; T.insert(s+i, k); &#125; printf(\"%d\", ans); return 0;&#125;","categories":[{"name":"败犬","slug":"败犬","permalink":"kuyon-veine.github.io/categories/败犬/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"kuyon-veine.github.io/tags/模拟赛/"}]}],"categories":[{"name":"败犬","slug":"败犬","permalink":"kuyon-veine.github.io/categories/败犬/"}],"tags":[{"name":"模拟赛","slug":"模拟赛","permalink":"kuyon-veine.github.io/tags/模拟赛/"}]}